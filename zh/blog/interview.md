---
title: 一些面试记录
date: 2024-10-06
---

<BlogCover src="/images/interview/cover.jpg" />

# 一些面试记录

因为想换一个团队，所以最近一直在面试，我这个人在平时一直疏于总结，所以无论在学生时代还是工作中多多少少都吃过亏。借这次机会希望能养成积累总结的好习惯

## Team A

### 第一面 - 技术面

#### 关于在业务里搭建的 canvas Table 组件

1. **问**：为什么会想到做这样一个组件？

   **答**：原因主要有两个。第一是 DOM 版本的性能比较差，行列过多时容易出现卡顿。第二是不满足业务需求，不满足数据分组的样式需求

2. **问**：一个列表数据存在多个分组数据时，是一次性批量加载，还是分批加载？

   **答**：对于未出现在用户视口内的分组，不进行数据加载。但是如果用户视口内出现100个分组，没有对请求数量进行限制，会同时并发请求

3. **问**：对于首屏数据，深层级数据，以及可能会实时变化的分组数据，分别是怎么处理的？

   **答**：首屏数据只会加载前 50 条，并且默认只会展开前两层，更深层级的数据需要用户主动去点开节点加载。对实时变化的场景没有做过多处理，后台不会去轮询校验数据的实时性，如果某个分组数据确实变化了（比如被删除了），只有用户主动刷新页面才能看到正确的数据

4. **问**：大概有多少个业务方接入？覆盖的范围是多少？

   **答**：已知大概有 4-5 个场景落地，推广与覆盖范围目前仅局限于部门内

#### 关于富文本编辑器

1. **问**：看是基于某个 SDK 进行封装，你又做了什么工作？

   **答**：主要是封装一些业务场景内更加常见且通用的功能，例如多语言，变量插入。提高业务开发效率

2. **问**：开发中的难点有哪些？

   **答**：踩的坑比较多。以插入图片为例，整个流程分为鉴权token的获取，上传URL的拼接。这部分逻辑需要封装在组件内，同时适配不同业务方的API接口。另外由于是使用公司内部 SDK，同类编辑器在复制粘贴内容时，会因为底层数据结构相同导致触发不了图片上传的钩子函数，导致无法正确上传。解决方法是对组件内的所有图片数据打标，未打标但又符合图片数据结构的内容重新走一遍上传逻辑

3. **问**：对编辑器底层的数据结构是否有了解？

   **答**：有一定了解，数据结构为 delta，插入内容放在 insert 属性，数据都放在 attributes 里。编辑器分为三种操作 insert，delete 和 retain。拆分为数组形式更有利于处理文档协同的场景

#### 其他

1. **问**：有没有独立 owner 和推动过一些项目？

   **答**：比较少，大部分技术产出都是随着需求去推动（这里后来面试官进行了纠正，不一定自己提出并推动的项目，例如 owner 一个模块的性能优化的工作也属于该范畴）

2. **问**：看你做过有关性能优化的工作，其中收益比较明显的手段是接口预请求以及接口懒加载？

   **答**：这二者属于一部分，更明显的部分主要在于我将项目从一个巨石应用中抽到新的 monorepo 中，让项目体积有一个较大的优化

#### 总结

问的问题其实大多都答了出来，更多还是围绕具体做的东西上问。面试官的思路明显很清晰，说话很有条理，这其实是我印象比较深刻的点。

但很明显 toB 与 toC 的产品会存在较大差别，加上面试的部门会偏移动端一些，而之前的业务一直是在做 PC 端，会显得没有什么优势

### 第二面 - 技术面

1. **问**：觉得现在业务内比较大的架构痛点是什么？

   **答**：比较公式化的列表页面，但是没有形成统一的解决方案，每个模块都是不同团队在维护，后端接口协议，前端技术实现上都有差异

2. **问**：为什么会造成不同团队维护的问题？

   **答**：整体业务功能比较大，所以不同 Tab 页下还是由不同的部门 & 团队去维护

3. **问**：那怎么去解决痛点？

   **答**：最好还是拉齐一套列表解决方案。每有一个新页面的产生，直接接入即可。后端接口结构是相同的。前端对于筛选，排序等处理已经封装好，并且有成熟的物料组件去接入

4. **问**：如果让你去主导，你的思路是什么？如何去推动？

   **答**：
   
   1. 首先是技术形态上面。可能会有几种选择

      1.1 sdk 形式，每个业务方去安装接入

      1.2 脚手架形式，cli 交互生成模板代码

      1.3 低代码平台方式（面试的时候遗漏了该选择，虽然可能有些花哨）

   2. 然后是方案协议上与后端对齐，产品形态上与产品，设计对齐，不要出现每个模块表现不一致
         
   3. 然后投入人力开发，在一个新的页面场景落地
         
   4. 最后分析需求投入的人力相较于之前降低了多少，并横向推广到其他团队

5. **问**：如果去说服后端去采用你这一套方案？以及如何保证协议上具有可扩展性？

   **答**：理由可能更多是人效上的提升，例如之前开发需要对齐某个字段代表前端渲染什么，现在接入方案后，无需再浪费时间投入在这方面的设计上。

   可扩展性更多需要充分调研每个业务方向的列表形态，主要是单元格渲染上，保证协议上的定义能覆盖目前大部分场景

6. **问**：之前有C端的经验吗？觉得B端转C端有什么困难点？

   **答**：没有C端经验。困难点第一是思维上的转变，B端可能更重用户的交互，但是缺少对用户各个维度的分析，C端偏重移动端场景，又依赖各个指标进行分析。第二可能是经验方面的，面对同一个问题，B端与C端在处理上会存在差异，经验的积累沉淀显得比较重要

7. **问**：算法题：2个鸡蛋，100层楼，可以从每一层楼扔鸡蛋，某一层开始鸡蛋可能会碎，求鸡蛋不会碎的最高层至少需要扔多少次 

   **答**：只说出了二分，没有说出最优解，过了几天在 leetcode 的每日一题遇到了 [鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/description/?envType=daily-question&envId=2024-10-14)

```js
/**
 * @param {number} k
 * @param {number} n
 * @return {number}
 */
var superEggDrop = function(k, n) {
    const calc = (k, t) => {
        if (t === 1 || k === 1) {
            return t + 1
        }

        return calc(k-1, t-1) + calc(k, t-1)
    }

    let t = 1;
    while(calc(k, t) < n+1) {
        t++;
    }

    return t;
};
```

#### 总结

到这一面流程就终止了，可能个别的问题确实答得不太好，而且问的深度与广度确实相比下来确实会大一些，目标团队可能缺少的是一些更资深的同学，而我的能力还没有达到

## Team B

### 第一面 - 初步了解

1. **问**：为什么考虑换一个团队？

   **答**：主要是业务发展不够理想，在 toB 领域里对个人发展有些受限。加上业务属性太过无趣，与现有社会热点脱节

2. **问**：有没有想过换到一个新的团队会与你的预期不符？

   **答**：有想过，但目前所在的业务技术挑战性太小，个人得不到成长，所以想找一个业务发展更好的团队

3. **问**：刚才听你的阐述，离开的原因主要是因为业务，但你个人又想做技术的事情，两者似乎有些矛盾？

   **答**：我觉得两者不算完全矛盾，在业务发展中也可以利用技术去解决问题（这里忘记举实际例子了，其实个人工作中的主要技术产出都是跟着业务走的）

4. **问**：你对未来的规划是什么？

   **答**：没有太过长远的规划，但是目前所在的位置资历可能还比较浅，所以希望能花 1 - 1.5 年在能力，无论是技术还是项目管理能力，得到一个比较大的提升。然后再花 1 - 1.5 年，看自己能不能往下一个阶段走

5. **问**：我们可能是一个更加偏向业务的团队，你对未来的发展方向有什么想法？

   **答**：我之前可能一直想往技术方向走，但是渐渐的觉得在这样一个大环境下单纯靠技术会比较困难。所以可能更希望能 owner 一个业务方向

#### 总结

有一些问题感觉答得不太好，特别是可能我在业务与技术两个方向中摇摆不定，让面试官觉得我没完全考虑清楚。其实换团队也没有什么太多理由，最直接的还是往业务发展前景上考虑

### 第二面 - 技术面

1. **问**：搭建这样的后台管理系统时，有没有遇到过什么性能问题？

   **答**：在配置数据较多（比如 50 条）时，会有一些性能问题。主要原因是表单会有许多联动校验（比如重名校验），一条行数据会全量订阅其他行数据的更新，导致每一行配置在变化时都会触发其他行的渲染。解决方法主要是进行更加细粒度的更新订阅，例如对于「名称」这一列需要进行重名校验，就只订阅其他配置行的「姓名」数据，而非一整行

2. **问**：这样的后台管理系统与低代码有什么相似的地方？

   **答**：这个问题的提出更多是因为我提了一嘴说搭建的后台管理系统与低代码有些相似之处。但其实二者还是有比较大的区别的，这种后台管理系统的功能大多是配置一个表单模板，然后在前台再以另外一个页面让用户去填写。并不具备低代码平台那种可视化拖拽配置，代码生成的能力。
   
   其实这也一定程度上反映了为什么我想离开，因为长期在这种 toB 产品下，感觉技术视野受到了限制。无论是业务，团队，还是说具体到人，都没让我感觉到能继续成长

3. **问**：平时业务评价一个功能做的好不好，有没有什么指标去衡量？

   **答**：toB 产品相对指标比较少，PV 和 UV 最多也就一天几千的样子。更多是通过季度的需求交付率，用户渗透率，或者产品线下调研的结果去衡量

4. **问**：在做 canvas Table 这样的组件时，主要挑战是什么？

   **答**：第一是分组数据加载的实现，需要在 canvas 内实现进入用户视口内再进行数据加载，这个借助了底层框架的组件生命周期实现，并且 Table 内部封装了关于对异步竞态的处理。
   
   第二是列宽拖拽，由于底层框架的限制，在 canvas 里父组件会约束子组件的布局与渲染，导致渲染列宽拖拽热区时，体验并不理想，鼠标 hover 到左右两侧过程中会有割裂感，解决办法是在原 Table 的表头上再盖一层 Table，一层负责表头渲染，一层负责热区渲染，这样摆脱了原表头的布局限制

   第三是单元格浮层组件的实现，底层框架提供了类似 popover 的组件，但具体实现都是由我们实现，需要处理 web component，常见的 menu 等组件。而且过程中发现 popover 挂载点，以及卸载逻辑，是业务内通用的问题。于是将处理统一收敛到了 canvas Table 组件内部

5. **问**：做富文本编辑器时，图片的处理流程大概是怎么样的？

   **答**：上传服务是公共的，所以需要保证前端的一致。先获取用户鉴权 token，然后拼接 url 进行文件上传。对于外部粘贴进来的图片，可能是单纯一个 url 形式，需要前端主动 fetch 把图片下载下来，转成 blob 格式，再走上传流程

   **问**：这样的处理流程对前端是否过重了？应该让后端去处理图片 url 等场景

   **答**：是的，目前对前端来说这部分逻辑很重，但是由于后端服务是公共的，所以短期内可能没办法解决。暂时较为理想的做法是把这一层逻辑都收敛到富文本编辑器里

#### 总结

这个技术面也主要是围绕做的东西去展开的，侧重点有所不同，但基本上答得也还行。不过面试官的技术能力看出来也是很强的，特别是提出富文本图片上传一块，逻辑对前端过重这一点。后来翻了翻面试官的文章，原来除了前端还会负责部分服务端的工作，所以有相关的经验也不奇怪

### 第三面 - leader 面

1. **问**：聊一聊你觉得工作中最有挑战性的项目？

   **答**：感觉还是当初做 canvas Table 比较有挑战性，当然主要是因为接触到的技术都比较新鲜

2. **问**：有没有想过为什么将 DOM 切成 canvas 后，在性能上会有一个明显的提升？

   **答**：这一层其实没有认真思考过，最直观的是在浏览器里渲染数万个 DOM 转为只渲染一层 canvas，肯定能带来不少的收益

   **问**：那有没有了解过使用的底层 canvas 框架，它对性能做了哪些优化？

   **答**：了解过框架的基本原理，其实是类似 React 自行实现了一套 canvas 渲染框架。对基本流程有所了解，但是对内部如何进行性能优化可能知道的比较少。
   
   有一些点可以提，比如也会存在类似虚拟DOM的概念，底层通过 `setState()` 会对组件进行标脏，然后遍历子节点进行更新。其中还会对组件分为 statefulWidget 和 statelessWidget，无状态的组件可以直接略过更新

3. **问**：实现富文本编辑器时，有了解过它基本的原理吗？以及它的数据结构是什么？

   **答**：基本原理还是基于浏览器的 `contenteditable` 属性实现，还是一个 div 标签。整体流程遵循 MVC 模型，监听用户的 input 等事件，然后修改底层数据结构，触发视图层更新。数据结构是 delta 形式，字体的粗斜体等信息都放在 attributes 内

4. **问**：有了解过 SDK 的团队针对富文本做过什么优化吗？

   **答**：有一些了解，最初富文本渲染时还是依赖 React 框架，但渐渐地发现性能会受影响。于是自研了一套 JSX，内部用纯 DOM 渲染去提升性能

<!-- 5. **问**：聊一下最近几次的绩效表现

   **答**： -->

#### 总结

这个团队的 leader 给我的第一印象就是：爽快，亲切。毕竟我不太喜欢浪费太多时间与其他人讨论一些没有意义的事情。

从他围绕 canvas 和 富文本 提的问题能感受到技术水平也很强，毕竟站在他这个层级看到的东西肯定和我不一样，也暴露了一些我容易产生惯性思维的问题，以及平时缺少进一步研究追问的精神

## Team C

### 第一面 - 技术面

1. **问**：性能优化里你是怎么分析，以及做了哪些手段？

   **答**：整个项目是作为微前端的一个子应用运行的，所以接入预请求带来的提升会比较明显。另外由于整个项目差不多是一个 canvas 画布，所以目标是让用户先看到 canvas 的内容，其他 DOM 元素进行延迟加载，特别是组件库的初始化流程耗时会比较长，所以对组件进行了懒加载

2. **问**：项目是展示一幅组织架构图，由此展开来说，一个有向图寻找最深层级的算法是什么？时间复杂度是多少？

   **答**：这里我回答了 BFS，但面试官想听到的答案应该是 DFS ？时间复杂度我没答上来，说了 O(n)，面试官问我不用考虑节点和边的数量吗？我说不太清楚了，很久没有复习这一块的知识。其实时间复杂度应该是 O(n + m)

3. **问**：在实现 canvas Table 的过程中，有了解底层渲染引擎的基本原理吗？

   **答**：有一定了解过，整个组件的生命周期分为 build，layout 和 paint 三个阶段。build 负责创建组件的状态state；layout 负责布局排版，遵循父节点向子节点传递约束，子节点向父节点返回确定的大小，父节点再根据子节点的大小确定子节点的位置；paint 负责调用 canvas 底层的 API 进行绘制。

   另外框架的更新依赖于 `requestAnimationFrame`，当组件 `setState()` 时，会进行标脏，然后在下一帧重复执行上面三个阶段

4. **问**：看你们项目中使用了 zustand，为什么选用？有考虑过项目其他成员的上手成本吗？

   **答**：主要还是不想继续用比较老的 redux，并且看社区内 zustand 比较流行。因为写法上与 redux 比较接近，所以认为上手成本还好

5. **问**：zustand 与 redux 的主要区别在哪里？有了解过其他状态管理框架吗？比如 rxjs，swr

   **答**：这里其实没答出来具体有什么区别，redux 太久没有用过了，二者其实都是基于 flux 模型实现的。后来查了一下 zustand 官网，有一些[与 redux 的对比](https://zustand.docs.pmnd.rs/getting-started/comparison#state-model-(vs-redux))。基本概括为：二者都是围绕 immutable 状态模型，只不过 redux 需要 Context Provider，而 zustand 不需要。至于渲染优化上二者同样没有太多差别，都是建议用 selector 去优化

   至于其他状态管理框架基本上能说的都说了...。除了 zustand 的另外两家，原子化的 jotai 和 基于 proxy 实现的 valtio。传统派的 redux 与 mobx。还有一些另类的方案如状态机 xstate。

   rxjs 有了解过但实际开发中没用过（这里不得不提团队里也盛行 rxjs，不知道是从何时而起的风气，无论是状态管理，还是异步请求都说 rxjs 能解决问题。其实我个人认为 rxjs 所推行的 FP 思想是有利于去建模的，但是实际生产中引入这个方案并把它的价值实现到 50% 以上的例子实在是少之又少，随之而来的还有高额的上手成本。在开源社区内除了 Angular 能把 rxjs 玩出活来并且有借鉴意义的项目也是屈指可数）

   至于 swr 其实项目中也有用，当时选用这套方案主要是因为有 vercel 背书，但其实团队没有太多考虑到它的真正价值在哪里。把它与其他状态管理工具归为一谈其实是有待商榷的，毕竟它主要解决的问题是项目内对异步数据请求的处理，提供通用的 loading，error 等状态属性，同时解决组件之间数据复用，数据缓存，竞态请求等问题

6. **问**：算法题：实现一个类似 setInterval 的函数，在 a, a+b, a+2b... 执行，调用 `start()` 开始，调用 `stop()` 停止

   **答**：考算法题确实有些没想到，不过也不是那种 leetcode 算法题，所以勉强还算写了出来

```js
class MySetinterval {
  constructor(func, a, b) {
    this.func = func;
    this.a = a;
    this.b = b;

    this.count = 0;
    this.timeout = undefined;
    this.cleared = false;
  }

  start() {
    const f = () => {
      this.timeout = setTimeout(() => {
        this.func();
        this.count++;
        if (!this.cleared) {
          f();
        }
      }, this.a + this.b * this.count);
    };

    this.cleared = false;
    f();
  }

  stop() {
    clearTimeout(this.timeout);
    this.cleared = true;
    this.count = 0;
  }
}

const myInterval = new MySetinterval(
  () => {
    console.log('###aaa');
  },
  1000,
  2000
);

myInterval.start();

setTimeout(() => {
  myInterval.stop();
}, 10000);

```

#### 总结
这个结束面与其他几个都有些不一样，有一些往八股方面靠的问题我也确实没答出来，最后还考一道算法题确实是没想到的。把问的问题都好好地恶补了一下，不过其实我个人不太喜欢在状态管理那个话题上停留太久，本来就只是定位为一个项目工具，偏要把业界的方案都拿出来说一遍。还要在上手成本，开源工具是否有人维护这些问题上去纠结。

不过 zustand，jotai 和 valtio 这几个项目的维护者 daishi 确实是一个很了不起的人，这里也贴一下他写的 [关于 jotai 和 valtio 的对比](https://blog.axlight.com/posts/when-i-use-valtio-and-when-i-use-jotai/)

### 第二面 - 技术面

其实问的问题大致都相差无几，从项目开始展开

1. **问**：canvas Table 你主要承担的是哪些工作，觉得哪些部分比较有挑战性

   **答**：主要是表格部分功能的封装，如数据分组，异步加载处理，body 的渲染，以及部分单元格组件的封装。

   比较有挑战性的还是多个分组的异步加载处理，利用 `onMount` 生命周期作为分组 loading 出现在用户视口内的标记，然后进行异步数据拉取，同时需要考虑竞态等问题。还有就是列宽拖拽功能，受底层框架限制，无法实现类似 DOM 的 overflow 渲染，于是额外在又渲染了一层 Table 表头，单独来处理列宽拖拽的热区交互

2. **问**：canvas Table 设计之初有进行过技术调研吗？大致的架构是怎么设计的

   **答**：没有过多进行技术调研，因为刚好有基建工具能满足我们的需求。架构其实也没有太复杂，整体分为表格 Table，以及单元格渲染 widget 两个包。整个 Table 是 2 行 3 列的结构。至于数据响应式是基于 mobx 做的，因为底层渲染工具就是用的 mobx。数据与逻辑集中在一个 context 下进行书写和处理

3. **问**：富文本做了哪些封装？

   **答**：主要还是基于业务场景进行的封装，如变量插入，多语言，图片上传等。封装通用逻辑，以此来降低各个业务方的接入成本

4. **问**：变量插入是怎么去实现的，和后端的协议是什么？

   **答**：因为富文本底层数据结构是采取常用的 **delta**，所以与后端的协议也是如此。会在 `attributes` 属性中打 tag 去标记，这段文本是富文本，然后基于插件去进行渲染

5. **问**：富文本的单行和多行是怎么实现的？看右侧还会有实时预览，会不会造成填写与预览的排版不正确问题

   **答**：样式基于 CSS，富文本会监听用户的 `inputChange` 事件，单行模式下会把回车去掉。右侧实时预览是完全由 CSS 排版决定的，和左侧输入内容确实会有不一致的情况（这里其实感觉关注的点有些奇怪，毕竟页面中输入区和预览区的宽度本来就不一样，左右完全保持一致并不是一个功能诉求）

6. **问**：算法题：
```js
// Level traversal output

const obj = {
  a: {
    b: {
      c: { f: 'aa' },
    },
    d: {
      e: { g: 'bb' },
      h: { i: 'cc' },
    },
    j: {
      k: 'dd',
    },
  },
};
// output [f,g,i,c,e,h,k,b,d,j,a]
```

   **答**：这个在现场确实有些太紧张了，应该是每一层 BFS 扫，但是一开始写使用 DFS，导致没完全写出来。之前也有写过类似的，两层 queue 遍历就好

```js
const solve = obj => {
  let res = [];
  let queue = [obj];

  while (queue.length) {
    const nextQueue = [];
    const nextRes = [];

    while (queue.length) {
      const nextObj = queue.shift();
      if (typeof nextObj === 'object') {
        const entries = Object.entries(nextObj);
        nextQueue.push(...entries.map(([_key, obj]) => obj));
        nextRes.push(...entries.map(([key]) => key));
      }
    }

    res = [...nextRes, ...res];
    queue = nextQueue;
  }

  return res;
};
```


### 第三面 - leader 面

其实也是比较常规地围绕项目问，以及大致介绍未来团队的发展方向，不再过多记录了